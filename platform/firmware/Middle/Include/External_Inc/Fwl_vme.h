/*****************************************************************************
 * Copyright (C) 2003 Anyka Co. Ltd
 * Transmittal, reproduction and/or dissemination of this document as well
 * as utilization of its contents and communication thereof to others without
 * express authorization are prohibited. Offenders will be held liable for
 * payment of damages. All rights created by patent grant or registration of
 * a utility model or design patent are reserved.
 *****************************************************************************
 *    VME Version: 0.9$
 *****************************************************************************
 * $Workfile: fwl_vme.h $
 *     $Date: 2003/10/29 15:42:54 $
 *****************************************************************************
 * Requirements:
 * Target:  C16x Tasking C/ST10 6.0r6 or higher
 *****************************************************************************
*/

#ifndef _VME_H
#define _VME_H

/** \file */


/**
   \page vme_overview  VME Overview
   The VME (Virtual Module Environment) enables a module user to load and run his 
   own applications inside the module. These applications, called the userware, 
   are compiled and linked independently of the firmware and then loaded into a 
   separate memory area in the module. 
   The VME provides an API with all necessary interfaces for running customer programs 
   on the module. 
   
   This document describes the VME API, its functionality and usage.  Module capabilities 
   and functionality are covered in the AT Command Specification and the Hardware Interface 
   Description.

   \image html overview.jpg "VME API Overview" width=10cm
   \image latex overview.pdf "VME API Overview" width=10cm

   The VME API provides access for the userware to special hardware and software 
   functions by providing a standard function set for accessing all module features.
   The following components are part of the VME API:


   - Core: Calls the main loop of the customer software, triggers timer, drivers or asynchronous running function events. The Core is the single entry point to the userware. 
   - Timer: Provides functions for the configuration of SW Timers
   - Errors: Defines all errors, provides a function for requesting the last error
   - Events: Defines all possible events
   - Virtual AT Interface: Provides functions for sending AT-commands and receiving their responses
   - Flash File System: Provides an interface for accessing the flash file system on the module
   - TCP/IP: Provides basic TCP/IP networking functionality
   - Device Drivers: Access to internal module hardware components (keypad, v24) and to externally connected devices (displays, sound chip, ...)

   The VME interface consists of two parts. The first part, the VME stubs, contain API function stubs which are linked to
    the user application.  The second part is the VME main part.  It is part of the firmware and contains the API implementation
    and the adaptation of all other functionality of the module (TCP/IP, AT commands, V24, ...).
   
   The interface between the firmware and the userware consists of function calls.
   The firmware provides a set of API functions which are called by the userware and
   which are specified in this document.
    The userware provides a single entry point for userware initialization (VME_Main() function)
   and another entry point for all events generated by the firmware.
   The latter entry point needs to be registered with the firmware
   during initialization although it can also be changed later.
   
    @image html userwareifc.jpg "Interface Userware to Firmware" width=10cm
    @image latex userwareifc.pdf "Interface Userware to Firmware" width=10cm

    It is strongly recommended that the code in these callbacks not use any loops.
    Events can not be processed while the software is in a loop.  If too much time is spent in a loop event response
    time worsens.
    
*/

/**
   \page vme Core Introduction
  
   When the userware is started its VME_Main() function is called once.  VME_Main is not an API function but is the only 
   function that the userware must implement.
   The userware does not need to do all its initialization in this function but it should, at least,  register an event
   callback with VME_SetCallback(). This callback is the only entry point from the firmware
   into the userware.  It will receive every event generated by the firmware.    
   The callback registered during userware initialization will receive the #VME_EVT_SYSSTART event once.  
   
   It is recommended that the callback function, and its subroutines, do not contain any loops which require
   a lot of processing time.  During a loop the userware can not receive or process any 
   events.
    
    Any task which requires multiple execution of the same program
    code should use VME_ReTriggerEvent() to simulate a loop. By doing so, any events
    occurring during this simulated loop can still be processed.  Such a loop is described in the examples below.

    
\section vme_examples Examples

\subsection vme_example1 Simple User Application
    The simplest userware might look like this:

    @code

    #include "fwl_vme.h"

    vVOID MainCallback (vT_EvtCode Event, vT_EvtParam *pParam)
    {
        // add event processing here
    
        // terminate userware
        VME_Terminate ();        
    }
    
    
    // fixed address (or called from fixed address)
    // firmware jumps HERE to start userware    
    vVOID VME_Main(vVOID)         
    {       
        // do userware initialization here 
    
        // register callback for events
        VME_SetCallback(MainCallback);    
    }
   
    @endcode  

    When the userware is started, the main function registers the callback.  In this example,  the first
    event  received would terminate the program.
    
\subsection vme_example2 Event Processing
   
    In order for the userware to do something useful, some basic event processing 
    needs to be done in the callback function:
  
    @code

    vVOID MainCallback (vT_EvtCode Event, vT_EvtParam *pParam)
    {
        vT_EvtMainCode  MainCode = VME_EVT_MAINCODE(Event); 
        vT_EvtSubCode   SubCode = VME_EVT_SUBCODE(Event);
        
        // first check event maincode
        switch(MainCode)
        {
            case VME_EVT_V24:
            {
                // special event processing 
                V24EventProcessing(Event);
                break;
            }      
            case VME_EVT_TIMER:
            {
                // check event subcode
                switch(SubCode)
                {
                    case 1234:
                    {
                        // get event parameters
                        vUINT32 Param = pParam->lParam;

                        ...
                        
                        break;
                    }
                    ...
                } 
            }                  
            ...
        }
       
    }   

    @endcode  

\subsection vme_example3 Simulated Loop
   
   VME_ReTriggerEvent() is used to trigger an event from within the userware.
    A simulated loop using VME_ReTriggerEvent() might look like this:

    @code

    vVOID MainCallback (vT_EvtCode Event, vT_EvtParam *pParam)
    {
        // first check the event's main code
        switch(VME_EVT_MAINCODE(Event))
        {
            case VME_EVT_SYS:
            {
                if(Event == VME_EVT_SYSSTART)
                {
                    // this will start the loop
                    VME_ReTriggerEvent(LOOP_TASK_CODE, LOOP_START_VALUE);
                }
                break;
            }
        
            case VME_EVT_RETRIGGER:
            {
                // then go to sub code handling
                HandleRetriggerEvent(EVT_SUBCODE(event), pParam->lParam);
                break;
            }
            ...

        }

 
    }

    vVOID HandleRetriggerEvent (vT_EvtSubCode Code, vUINT32 Param)
    {
        if(Code == LOOP_TASK_CODE)
        {
            // Insert Loop Code here !

            // go on looping
            if(Param) VME_ReTriggerEvent(LOOP_TASK_CODE, Param-1);
        }
        ...
    
    }

    @endcode  
    
 */
 
/**
    \page events Event Handling

    An event consists of an event code and a parameter structure. Both are input parameters of
    the main callback function.

    The event codes are unambiguous.  
    To simplify processing, an event is split into a maincode (#VME_EVT_MAINCODE) and a subcode (#VME_EVT_SUBCODE).
    The event maincode defines the event group (e.g. #VME_EVT_TIMER) to which the event belongs and can not be defined by the user.
    The event subcode defines a specific event in a group. It can often be defined by the user:
    e.g. for timer or retrigger events.  

    The event parameter structure (::vT_EvtParam) delivered with an event contains information about that particular
    event.  Not all events use the event parameter structure.   The type of information contained in the event parameter 
    structure of a particular event is described in the documentation under the definition of an event.
    
    Examples "\ref vme_example2" and "\ref vme_example3" in the introduction show how events can be handled by the userware. 
    
*/

/** 
\defgroup scheduler Interface fwl_vme.h
This interface contains the basic VME definitions. This is the the only header file which must
included in all userware programs.  Other header files are included as necessary.
*/
/*@{ */
#ifndef VME_DOXYGEN_SHOULD_SKIP_THIS   
/* DO NOT USE !! WILL BE REMOVED !! */
#define MAX_PAGE_SIZE_C166  (16384)
#endif
/**
@defgroup btypes Basic Data Types
@ingroup scheduler

These are the basic VME data types which are used by all VME functions.
It is strongly recommended that these data types be used in every VME based userware
application.
*/
/*@{ */
typedef signed char     vINT8;          ///< basic VME type: signed 8 bit
typedef unsigned char   vUINT8;         ///< basic VME type: unsigned 8 bit
typedef signed short    vINT16;         ///< basic VME type: signed 16 bit
typedef unsigned short  vUINT16;        ///< basic VME type: unsigned 16 bit
typedef signed long     vINT32;         ///< basic VME type: signed 32 bit
typedef unsigned long   vUINT32;        ///< basic VME type: unsigned 32 bit
typedef unsigned char   vBOOL;          ///< basic VME type: boolean
typedef char *          vPSTRING;       ///< basic VME type: pointer to character, a string
typedef unsigned char * vPDATA;         ///< basic VME type: pointer to data
typedef char            vCHAR;          ///< basic VME type: single character
typedef void            vVOID;          ///< basic VME type: void
typedef void *          vPVOID;         ///< basic VME type: pointer to void


#define vTRUE  1
#define vFALSE 0
/*@} */


/** 
@defgroup events System Events
@ingroup scheduler
*/
/*@{ */
typedef vUINT16  vT_EvtCode;                                 ///< event code
#define VME_EVT_MAINCODE(a)           (a&0xf000)            ///< Macro to extract event main code from event code
#define VME_EVT_SUBCODE(a)            ((a&0x0fff))   ///< Macro to extract event sub code from event code
typedef vUINT16        vT_EvtSubCode;                              ///< event sub code
typedef vUINT16        vT_EvtMainCode;                             ///< event main codes

enum                                                        ///< event main codes
{
    VME_EVT_RETRIGGER = 0x1000,                             ///< Retrigger event
    VME_EVT_TIMER = 0x2000,                                 ///< Timer event
    VME_EVT_TCPIP = 0x3000,                                 ///< TCP/IP event
    VME_EVT_V24 = 0x4000,                                   ///< V24 event
    VME_EVT_VATC = 0x5000,                                  ///< Virtual AT event
//  VME_EVT_FSFLASH =0x6000,                                ///< Flash Filesystem event
    VME_EVT_MEDIA = 0x7000,                                    ///< Media Driver event
    VME_EVT_KEYPAD = 0x8000,                                ///< Keypad Driver event
    VME_EVT_SOUND = 0x9000,                                 ///< Sound Driver event
    VME_EVT_SYS = 0xa000,                                   ///< VME (system) event
    VME_EVT_PINIO = 0xb000,                                 ///< Pin IO event
    VME_EVT_INTHDL = 0xc000,                                ///< Interrupt Handler Driver event
    VME_EVT_USER = 0xd000,                                   ///< Free for user defined events  
    VME_EVT_TOUCHSCR = 0xe000,                                ///< touch screen event
    VME_EVT_LKBLUETOOTH = 0xf000                            ///< bluetooth event

};

#define VME_EVT_DISPLAY VME_EVT_MEDIA        ///< Display Driver event

typedef union                                         
{  
    struct                                             
    {                                                
        vUINT8 Param1;                                       
        vUINT8 Param2;                                      
        vUINT8 Param3;                                      
        vUINT8 Param4;                                      
        vUINT8 Param5;                                      
        vUINT8 Param6;                                       
        vUINT8 Param7;                                       
        vUINT8 Param8;                                     
    } c;                                               
                                         
    struct                                              
    {                                                  
        vUINT16 Param1;                         
        vUINT16 Param2;                         
        vUINT16 Param3;                         
        vUINT16 Param4;                         
    } s;                                               
    struct                                              
    {                                                
        vINT32 Param1;                                       
        vINT32 Param2;                                       
    } l;                                               
    struct                                              
    {                                                  
        vPVOID pParam1;
        vPVOID pParam2;
        vPVOID pParam3;
    } p;                                               
    struct                                              
    {                                                
        vUINT32 Param1;                               
        vUINT32 Param2;                               
    } w;      
    vPVOID lpParam;                                      
    vUINT32 lParam;                                       
} vT_EvtParam;         ///< Union for event message parameters.                                      


// for compatible to PMP MMI
typedef vT_EvtCode  T_EVT_CODE;
typedef vT_EvtParam T_EVT_PARAM;


/*@} */
    
/**
@defgroup cerror Core Error Codes
@ingroup error

These status codes are not related to any particular functional group of the API.  They belong to the
core VME functionality.
*/
/*@{ */
#define VME_NOERROR                     (0)        ///< No Error Code
/*@} */

/**
@defgroup vevents Core Events
@ingroup scheduler events

These events are not related to any particular functional group of the API.  They are related to the
core VME functionality.
*/
/*@{ */
#define VME_EVT_SYSSTART                 ((VME_EVT_SYS)+1)          ///< When the module  is started in GSM Normal Mode this is the first event the userware receives <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none 

#define VME_EVT_SYSSTART_ALARMMODE       ((VME_EVT_SYS)+2)          ///< When the module is started in Alarm Mode this the first event the userware receives <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none 
#define VME_EVT_SYSSTART_CHARGEONLYMODE       ((VME_EVT_SYS)+3)     ///< When the module is started in Charge Only Mode, first event the userware receives <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none 
/*@} */

#define VME_EVT_SUBTHREAD_NOTIFY       ((VME_EVT_SYS)+4) 
#define VME_EVT_SUBTHREAD_FINISH       ((VME_EVT_SYS)+5) 

/**/
#define VME_EVT_DEL_ALL                  ((VME_EVT_SYS)+6) // for delete all operation

                                                                  
#define VME_EVT_WM_READY       ((VME_EVT_SYS)+7)     ///< When the module is alive <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none 
#define VME_EVT_WM_DEAD       ((VME_EVT_SYS)+8)     ///< When the module is alive <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none        
#define VME_EVT_WM_ATCMD_OK       ((VME_EVT_SYS)+11)     ///< When the module is alive <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none 
#define VME_EVT_WM_ATCMD_ERROR      ((VME_EVT_SYS)+12)     ///< When the module is alive <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none        
#define VME_EVT_WM_INITIALIZE_START      ((VME_EVT_SYS)+13)     ///< When the module is alive <br>
                                                                    ///< Parameter: <br>        
                                                                    ///< none           
#define VME_EVT_PAINT               ((VME_EVT_SYS)+14)          /**repaint*/
/*@} */

/** @{@name USB Event define
 *    Define event caused by USB
 */
/**    suggest the usb data in buffer is full */
#define VME_EVT_USB_DATA_IN__FULL            (VME_EVT_INTHDL+1)

/**    suggest the usb host is connected */
#define VME_EVT_USB_PLUG                    (VME_EVT_INTHDL+2)

/**    data send request */
#define VME_EVT_USB_SEND_REQUEST                    (VME_EVT_INTHDL+3) 

/** data detect usb device plug */
#define VME_EVT_USB_DEVICE_PLUG                    (VME_EVT_INTHDL+10)
 
/** data detect usb device plugOUT */
#define VME_EVT_USB_DEVICE_PLUGOUT                    (VME_EVT_INTHDL+11)
/** @} */





/**
@defgroup tV24events V24 API Events
@ingroup v24 events
*/
/*@{ */
#define VME_EVT_V24_STATUS_LINES_CHANGED (VME_EVT_V24+1)  ///< any input status line changed <br>
                                                          ///< Parameter: <br>
                                                          ///< c.Param1: device handle <br>
                                                          ///< c.Param2: current DTR state <br>
                                                          ///< c.Param3: current RTS state <br>

#define VME_EVT_V24_RECEIVED_DATA_AVAIL  (VME_EVT_V24+2)  ///< received data available and ready to read <br>
///< <b> Please note: </b> <br>
///< This event is sent if data is available in the receive buffer and ready to read with VME_v24Read. Please
///< note that at least one byte must be read by the userware for the event to be sent again. <br>
///< Parameter: <br>
///< c.Param1   device handle

#define VME_EVT_V24_WRITE_CALLBACK       (VME_EVT_V24+3)  ///< API is able to transmit data again <br>
                                                          ///< Parameter: <br>
                                                          ///< c.Param1: device handle
/** @{@name GPIO Event Define
 *    Define the event caused by GPIO
 */
#define VME_EVT_PINIO_FLIP              (VME_EVT_PINIO + 0) ///< digital input change detected on pin IRQ_FLIP
#define VME_EVT_PINIO_CHARGE_DETECT     (VME_EVT_PINIO + 1) ///< digital input change detected on pin IRQ_CHARGE_DETECT
/** @} */



#define VME_EVT_TOUCHSCR_ACTION     (VME_EVT_TOUCHSCR+1)       //< low level touch screen change indication <br>
#define VME_EVT_TOUCHSCR_HOTKEY        (VME_EVT_TOUCHSCR+2)



typedef void (*vT_MainCallback)     (vT_EvtCode, vT_EvtParam*);         ///< Userware main callback
typedef void (*vT_UserwareInit)     (void);                             ///< Userware initialization function

/********************************************************************************/
#ifndef VME_DOXYGEN_SHOULD_SKIP_THIS   
vVOID VME_StdWrite (vUINT16 Chan, vCHAR *pBuffer, vUINT16 Length);

enum VME_DATA_IDENTIFIER
{
     eID_vT_VME_Version = 0x100,
     eID_ManyIdentifiers
};

typedef struct
{
     vCHAR major[2];
     vCHAR point;
     vCHAR minor[3];
     vCHAR prj[122];
} vT_UW_Version;

typedef struct
{
     enum VME_DATA_IDENTIFIER id;
     vUINT16 major;
     vUINT16 minor;
     vUINT16 chksum;     /* the sum of all elements of struct must be 0 !*/
} vT_VME_Version;
#endif
/********************************************************************************/
/**
   This is the main callback registration. The userware needs to call this function at least
   once during initialization (VME_Main()). The callback can be changed later
   by calling this function again.

\param maincallback     [in] userware main callback function  

*/
vVOID VME_SetCallback (vT_MainCallback maincallback);

/********************************************************************************/
/**
   Terminates userware execution. There will be no further calls to the main callback function. 
    No further API functions can be called after this function has been called .

*/
vVOID VME_Terminate (vVOID);

/********************************************************************************/
/**
    This functions allows userware to trigger itself.  An event with maincode #VME_EVT_RETRIGGER and the desired
    subcode will be generated. The parameter passed in param will be placed in the lparam field of the event structure.

\param event            [in] event subcode
\param param            [in] event parameter

*/
vVOID VME_ReTriggerEvent(vT_EvtSubCode event, vUINT32 param);

/*@} */

vVOID VME_ReTriggerUniqueEvent(vT_EvtSubCode event, vUINT32 param);

#define EVT_SD_PLUG_OUT         0
#define EVT_SD_PLUG_IN          1
#define EVT_SD_DESTROY          2
#define EVT_USB_PLUG_IN         3
#define EVT_USB_PLUG_OUT        4
#define EVT_USB_CAMERA_IN       5
#define EVT_VIDEO_REC_STOP      6
#define EVT_PASTE_FILE_INTERNAL 7
#define EVT_USB_DISK_IN         8
//add for alarm info indicate that alarm arrived
#define EVT_RTC_TRIGGER         9

/********************************************************************************/

/**
    \page vme_egold Platform Introduction

    The E-Gold+ V3 is a GSM Baseband System designed by Infineon which combines
    a C166S CPU with an OAK+ DSP.
    The implementation of the VME on the C166S has some characteristics
    which are CPU dependent. This is a brief overview. For detailed information 
    please refer to the documentation that comes with the Tasking Compiler for the C166S
    or the E-Gold+ V3 specification .

    \section vme_memmodel Memory Model
    Due to the paged memory model of the C166S CPU, only pointers which are limited
    to one page can be handled efficiently. Therefore, a standard C pointer (int *p) is a
    so called "far" pointer which can only point to a memory object which is
    at most 16kByte. If larger data objects are required, e.g. large bitmaps, 
    "shuge" (max. 64kByte) or "huge" (max. 16MByte) pointers must be used. Only use such pointers
    if really necessary and be careful when casting from one pointer type to another.

    \section vme_stacks Stacks
    The C166S CPU uses two different stacks. The "User Stack" referenced by the R0 register
    is used for local stack
    frames, e.g. local variables and parameter passing. The size of this stack is 16kByte.
    The "System Stack" referenced by the SP register is used for push/pop operations 
    and return addresses. The size of this stack is 340 Bytes.
    
    \section vme_exceptions Exceptions
    When executing invalid code or using invalid pointers a CPU exception might be generated.
    When this happens information about the exception is output over the first serial
    interface (ASC0) with a bitrate of 57600 bps before the module is switched off, e.g.
    @code
    Stack overflow, next program address: 40007c
    SYSTEM HALTED
    @endcode
    <br>
    The provided address can be a useful hint for finding the cause either by looking at the code
    or with a debugger. Possible exception messages are: <br>
    <UL>
    <LI>"Stack overflow"<br>
    (STKOF), SP decremented to value less than stack boundary. 
    
    <LI>"Stack underflow"<br> 
    (STKUF), SP incremented to a value greater than stack boundary. 
    
    <LI>"Undefined opcode"<br>
    (UNDOPC), instruction currently decoded is not a valid C166S instruction. 
    
    <LI>"Protection fault"<br>
    (PRTFLT), protection broken while executing a protected instruction. 
    
    <LI>"Illegal word operand access"<br> 
    (ILLOPA), word operand read or write access attempted to an odd byte address. 
    
    <LI>"Illegal instruction access"<br>
    (ILLINA), branch to odd byte address. 
    
    <LI>"Illegal external bus access"<br>
    (ILLBUS), instruction fetch or data read or data write and no bus configuration specified.
    </UL>    
 */
 

/**    
    \defgroup vme_memmodel Memory Model
*/
/*@{ */

/*@} */




#endif

